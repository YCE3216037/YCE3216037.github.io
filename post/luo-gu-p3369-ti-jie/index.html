<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>洛谷 P3369 题解 | Gridea</title>
<link rel="shortcut icon" href="https://YCE3216037.github.io/favicon.ico?v=1587119079346">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://YCE3216037.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="洛谷 P3369 题解 | Gridea - Atom Feed" href="https://YCE3216037.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="什么？！21页题解竟然没有一个人写 AVL 树，于是本蒟蒻就写一篇 AVL 树的题解。当然， AVL 树可能会比较难，而且常数较大，但如果有比较多的插入和删除 AVL 树就会有优势。
我们都知道，普通的二叉搜索树的插入、删除、查找期望时间复..." />
    <meta name="keywords" content="题解" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://YCE3216037.github.io">
  <img class="avatar" src="https://YCE3216037.github.io/images/avatar.png?v=1587119079346" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              洛谷 P3369 题解
            </h2>
            <div class="post-info">
              <span>
                2020-03-17
              </span>
              <span>
                15 min read
              </span>
              
                <a href="https://YCE3216037.github.io/tag/FxiZxcLA2/" class="post-tag">
                  # 题解
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>什么？！21页题解竟然没有一个人写 AVL 树，于是本蒟蒻就写一篇 AVL 树的题解。当然， AVL 树可能会比较难，而且常数较大，但如果有比较多的插入和删除 AVL 树就会有优势。</p>
<p>我们都知道，普通的二叉搜索树的插入、删除、查找期望时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，但在特殊构造的数据中时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，如图所示。<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/oyvfpmtu.png" alt="" loading="lazy"></p>
<p>但是，AVL 树有一个性质，就是两棵子树的高度差的绝对值不超过1，所以期望时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，最坏情况下时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msub><mi>log</mi><mo>⁡</mo><mi>ϕ</mi></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log_\phi n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.130248em;vertical-align:-0.380248em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2419679999999999em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">ϕ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.380248em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，如图所示。<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/acgb6w38.png" alt="" loading="lazy"><br>
由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>log</mi><mo>⁡</mo><mi>ϕ</mi></msub><mn>2</mn><mo>=</mo><mn>1.44</mn></mrow><annotation encoding="application/x-tex">\log_\phi2=1.44</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0746879999999999em;vertical-align:-0.380248em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2419679999999999em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">ϕ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.380248em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">4</span><span class="mord">4</span></span></span></span>，所以最坏情况的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msubsup><mi>log</mi><mo>⁡</mo><mn>2</mn><mn>1.44</mn></msubsup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log_2^{1.44} n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.148448em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">4</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，时间复杂度不高。</p>
<h2 id="做法">做法：</h2>
<h3 id="基本的节点定义">基本的节点定义：</h3>
<pre><code class="language-cpp">struct AVLnode;
typedef AVLnode* AVLtree;
struct AVLnode {
	int data, high;//权值，树高
	int freq, size;//频数，大小
	AVLtree ls, rs;//左子，右子
	AVLnode(): data(0), high(1), freq(1), size(1), ls(NULL), rs(NULL){}
	AVLnode(int a): data(a), high(1), freq(1), size(1), ls(NULL), rs(NULL){}//初始化
};
</code></pre>
<h3 id="获取及更新树高大小">获取及更新树高，大小：</h3>
<p>为了防止因访问空节点而导致 RE，所以要特定函数来获取及更新</p>
<pre><code class="language-cpp">inline int GetSize(AVLtree p) {//获取大小
	if (p == NULL) return 0;
	return p-&gt;size;
}
inline int GetHigh(AVLtree p) {//获取树高
	if (p == NULL) return 0;
	return p-&gt;high;
}
inline void update(AVLtree&amp; p) {//更新节点
	p-&gt;size = GetSize(p-&gt;ls) + GetSize(p-&gt;rs) + p-&gt;freq;
	p-&gt;high = max(GetHigh(p-&gt;ls), GetHigh(p-&gt;rs)) + 1;
}
</code></pre>
<h3 id="左右旋转">左右旋转：</h3>
<p>AVL 树的旋转方式有四种：左左，右右，左右，右左。</p>
<h4 id="左左">左左：</h4>
<p>假如有这样一颗二叉树，如图所示。<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/l3bpc4yd.png" alt="" loading="lazy"><br>
现在要插入21，则步骤如下（注意右下角的字）:<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/em7a9m63.png" alt="" loading="lazy"><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/4xftqv65.png" alt="" loading="lazy"><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/572my7q3.png" alt="" loading="lazy"></p>
<pre><code class="language-cpp">inline void LeftPlus(AVLtree&amp; p) {
	AVLtree q;
	q = p-&gt;ls;
	p-&gt;ls = q-&gt;rs;
	q-&gt;rs = p;
	update(p);
	update(q);
	p = q;
}
</code></pre>
<h4 id="右右">右右：</h4>
<p>假如有这样一颗二叉树，如图所示。<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/oe4z8x9a.png" alt="" loading="lazy"><br>
现在要插入55，则步骤如下：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/gq9ads9c.png" alt="" loading="lazy"><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/xlguww6z.png" alt="" loading="lazy"><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/1mrcjdku.png" alt="" loading="lazy"></p>
<pre><code class="language-cpp">inline void RightPlus(AVLtree&amp; p) {
	AVLtree q;
	q = p-&gt;rs;
	p-&gt;rs = q-&gt;ls;
	q-&gt;ls = p;
	update(p);
	update(q);
	p = q;
}
</code></pre>
<h4 id="左右及右左">左右及右左：</h4>
<p>左右要先把这颗二叉树向右旋转变成左左，再左旋；右左反之。</p>
<pre><code class="language-cpp">inline void LeftRight(AVLtree&amp; p) {//左右
	RightPlus(p-&gt;ls);
	LeftPlus(p);
}
inline void RightLeft(AVLtree&amp; p) {//右左
	LeftPlus(p-&gt;rs);
	RightPlus(p);
}
</code></pre>
<h3 id="中序遍历本题不需要但可当做调试语句">中序遍历(本题不需要，但可当做调试语句)：</h3>
<pre><code class="language-cpp">inline void OutPut(AVLtree p) {
	if (p == NULL) return;
	OutPut(p-&gt;ls);
	for (int i = 1; i &lt;= p-&gt;freq; ++i)
		write(p-&gt;data), putchar(32);
	OutPut(p-&gt;rs);
}
inline void output() {//主程序可以更简洁，下同
	OutPut(root);
}
</code></pre>
<h3 id="插入">插入：</h3>
<p>先按照普通二叉搜索树的方式插入，再进行调整。</p>
<pre><code class="language-cpp">inline void Insert(AVLtree &amp;p, int x) {
	if (p == NULL) {
		p = new AVLnode(x);//没有这个节点，直接插入一个
		return;
	}
	if (p-&gt;data == x) {//如果已经有这个树了，直接增加这个数的频率，更新这个节点即可
		++(p-&gt;freq);
		update(p);
		return;
	}
	if (p-&gt;data &gt; x) {//往左子树插入，左子树可能偏高
		Insert(p-&gt;ls, x), update(p);
		if (GetHigh(p-&gt;ls) - GetHigh(p-&gt;rs) == 2) {
			if (x &lt; p-&gt;ls-&gt;data)
				LeftPlus(p);//左左
			else
				LeftRight(p);//左右
		}
	}
	else {//往右子树插入，右子树可能偏高
		Insert(p-&gt;rs, x), update(p);
		if (GetHigh(p-&gt;rs) - GetHigh(p-&gt;ls) == 2) {
			if (x &gt; p-&gt;rs-&gt;data)
				RightPlus(p);//右右
			else
				RightLeft(p);//右左
		}
	}
	update(p);//别忘记更新
}
inline void insert(int x) {
	Insert(root, x);
}
</code></pre>
<h3 id="删除">删除：</h3>
<p>先按照普通二叉搜索树的方式删除，再进行调整。</p>
<pre><code class="language-cpp">inline void Erase(AVLtree&amp; p, int x) {
	if (p == NULL) return;//找不到这个树，直接返回
	if (p-&gt;data &gt; x) {//删左子树的数，右子树可能偏高
		Erase(p-&gt;ls, x), update(p);
		if (GetHigh(p-&gt;rs) - GetHigh(p-&gt;ls) == 2) {
			if (GetHigh(p-&gt;rs-&gt;rs) &gt;= GetHigh(p-&gt;rs-&gt;ls))//一定要加等号，同下，就是因为这个，本蒟蒻92分调了55分钟！
				RightPlus(p);
			else
				RightLeft(p);
		}
	}
	else if(p-&gt;data &lt; x) {
		Erase(p-&gt;rs, x), update(p);
		if (GetHigh(p-&gt;ls) - GetHigh(p-&gt;rs) == 2) {
			if (GetHigh(p-&gt;ls-&gt;ls) &gt;= GetHigh(p-&gt;ls-&gt;rs))
				LeftPlus(p);
			else
				LeftRight(p);
		}
	}
	else {
		if (p-&gt;freq &gt; 1) {//如果这个数的频率大于1，那么直接减去一个就可以了
			--(p-&gt;freq);
			update(p);
			return;
		}
		if (p-&gt;ls &amp;&amp; p-&gt;rs) {//左右子树都有
			AVLtree q = p-&gt;rs;//找这个数的后继
			while (q-&gt;ls) q = q-&gt;ls;
			p-&gt;freq = q-&gt;freq;
			p-&gt;data = q-&gt;data, q-&gt;freq = 1;//把q节点提上来
			Erase(p-&gt;rs, q-&gt;data);//这个节点肯定少于2个子树了，直接删除
			update(p);//别忘记更新
			if (GetHigh(p-&gt;ls) - GetHigh(p-&gt;rs) == 2) {
				if (GetHigh(p-&gt;ls-&gt;ls) &gt;= GetHigh(p-&gt;ls-&gt;rs))
					LeftPlus(p);
				else
					LeftRight(p);
			}
		}
		else {//如果只有一个子树，直接把这个节点的子树提上来即可，不需要更新
			AVLtree q = p;
			if (p-&gt;ls) p = p-&gt;ls;
			else if (p-&gt;rs) p = p-&gt;rs;
			else p = NULL;
			delete q;
			q = NULL;
		}
	}
	if (p == NULL) return;//注意这里还要判断，否则可能会RE
	update(p);//最后更新一下
}
inline void erase(int x) {
	Erase(root, x);
}
</code></pre>
<h3 id="根据数值找排名">根据数值找排名：</h3>
<pre><code class="language-cpp">inline int get_rank(AVLtree p, int val) {
	if (p-&gt;data == val) return GetSize(p-&gt;ls) + 1;//如果这个节点就是要找的数字，返回左子树的大小加1
	if (p-&gt;data &gt; val) return get_rank(p-&gt;ls, val);//如果这个节点大于要找的数字，往左找
	return get_rank(p-&gt;rs, val) + GetSize(p-&gt;ls) + p-&gt;freq;//往右找，返回值要加上左子树的大小和这个节点数出现的频数
}
inline int GetRank(int val) {
	return get_rank(root, val);
}
</code></pre>
<h3 id="根据排名找数值">根据排名找数值：</h3>
<pre><code class="language-cpp">inline int get_val(AVLtree p, int rank) {
	if (GetSize(p-&gt;ls) &gt;= rank) return get_val(p-&gt;ls, rank);//如果左子树的大小不小于排名，往左找
	if (GetSize(p-&gt;ls) + p-&gt;freq &gt;= rank) return p-&gt;data;//如果左子树的大小加上这个节点数值出现的频数不小于排名，返回这个数值
	return get_val(p-&gt;rs, rank - GetSize(p-&gt;ls) - p-&gt;freq);//往右找，主要排名要减去左子树的大小和这个节点数值出现的频数
}
inline int GetVal(int rank) {
	return get_val(root, rank);
}
</code></pre>
<h3 id="找前驱后继">找前驱后继：</h3>
<pre><code class="language-cpp">inline int GetPrev(int val) {//找前驱
	AVLtree ans = new AVLnode(-1LL &lt;&lt; 42), p = root;//从根节点开始找，初始答案赋最小值
	while (p) {//如果p节点不为空，则一直找
		if (p-&gt;data == val) {
			if (p-&gt;ls) {//如果找到这个数了，先找这个数的左子树，再一直往右找
				p = p-&gt;ls;
				while (p-&gt;rs)
					p = p-&gt;rs;
				ans = p;
			}
			break;
		}
		if (p-&gt;data &lt; val &amp;&amp; p-&gt;data &gt; ans-&gt;data) ans = p;//如果遇到一个比这个值小但大于当前答案的值的话，把答案赋给ans
		p = p-&gt;data &lt; val ? p-&gt;rs : p-&gt;ls;
	}
	return ans-&gt;data;
}
inline int GetNext(int val) {//找后继，与找前驱类似
	AVLtree ans = new AVLnode(1LL &lt;&lt; 42), p = root;
	while (p) {
		if (p-&gt;data == val) {
			if (p-&gt;rs) {
				p = p-&gt;rs;
				while (p-&gt;ls)
					p = p-&gt;ls;
				ans = p;
			}
			break;
		}
		if (p-&gt;data &gt; val &amp;&amp; p-&gt;data &lt; ans-&gt;data) ans = p;
		p = p-&gt;data &lt; val ? p-&gt;rs : p-&gt;ls;
	}
	return ans-&gt;data;
}
</code></pre>
<h3 id="完整代码如下注释前面有了就不写了">完整代码如下(注释前面有了，就不写了)：</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int N = 100000 + 10;
template&lt;class T&gt; inline void read(T &amp;x) {
	char c = 0;
	int f = x = 0;
	while (c &lt; 48 || c &gt; 57) {
		if (c == '-')
			f = 1;
		c = getchar();
	}
	while (c &gt; 47 &amp;&amp; c &lt; 58) x = (x &lt;&lt; 3)+(x &lt;&lt; 1)+(c &amp; 15), c = getchar();
	if (f) x = -x;
}
template&lt;class T,class... Args&gt; inline void read(T &amp;x, Args&amp;... args) {
	read(x), read(args...);
}
template&lt;class T&gt; inline void write(T x) {
	if (x &lt; 0) {
		putchar(45);
		write(-x);
		return;
	}
	if (x &gt; 9) write(x / 10);
	putchar((x % 10) | 48);
}
struct AVLnode;
typedef AVLnode* AVLtree;
struct AVLnode {
	int data, high;
	int freq, size;
	AVLtree ls, rs;
	AVLnode(): data(0), high(1), freq(1), size(1), ls(NULL), rs(NULL){}
	AVLnode(int a): data(a), high(1), freq(1), size(1), ls(NULL), rs(NULL){}
};
inline int GetSize(AVLtree p) {
	if (p == NULL) return 0;
	return p-&gt;size;
}
inline int GetHigh(AVLtree p) {
	if (p == NULL) return 0;
	return p-&gt;high;
}
struct AVL {
	AVLtree root;
	inline void update(AVLtree&amp; p) {
		p-&gt;size = GetSize(p-&gt;ls) + GetSize(p-&gt;rs) + p-&gt;freq;
		p-&gt;high = max(GetHigh(p-&gt;ls), GetHigh(p-&gt;rs)) + 1;
	}
	inline void LeftPlus(AVLtree&amp; p) {
		AVLtree q;
		q = p-&gt;ls;
		p-&gt;ls = q-&gt;rs;
		q-&gt;rs = p;
		update(p);
		update(q);
		p = q;
	}
	inline void RightPlus(AVLtree&amp; p) {
		AVLtree q;
		q = p-&gt;rs;
		p-&gt;rs = q-&gt;ls;
		q-&gt;ls = p;
		update(p);
		update(q);
		p = q;
	}
	inline void LeftRight(AVLtree&amp; p) {
		RightPlus(p-&gt;ls);
		LeftPlus(p);
	}
	inline void RightLeft(AVLtree&amp; p) {
		LeftPlus(p-&gt;rs);
		RightPlus(p);
	}
	inline void OutPut(AVLtree p) {
		if (p == NULL) return;
		OutPut(p-&gt;ls);
		for (int i = 1; i &lt;= p-&gt;freq; ++i)
			write(p-&gt;data), putchar(32);
		OutPut(p-&gt;rs);
	}
	inline void output() {
		OutPut(root);
	}
	inline void Insert(AVLtree &amp;p, int x) {
		if (p == NULL) {
			p = new AVLnode(x);
			return;
		}
		if (p-&gt;data == x) {
			++(p-&gt;freq);
			update(p);
			return;
		}
		if (p-&gt;data &gt; x) {
			Insert(p-&gt;ls, x), update(p);
			if (GetHigh(p-&gt;ls) - GetHigh(p-&gt;rs) == 2) {
				if (x &lt; p-&gt;ls-&gt;data)
					LeftPlus(p);
				else
					LeftRight(p);
			}
		}
		else {
			Insert(p-&gt;rs, x), update(p);
			if (GetHigh(p-&gt;rs) - GetHigh(p-&gt;ls) == 2) {
				if (x &gt; p-&gt;rs-&gt;data)
					RightPlus(p);
				else
					RightLeft(p);
			}
		}
		update(p);
	}
	inline void insert(int x) {
		Insert(root, x);
	}
	inline void Erase(AVLtree&amp; p, int x) {
		if (p == NULL) return;
		if (p-&gt;data &gt; x) {
			Erase(p-&gt;ls, x), update(p);
			if (GetHigh(p-&gt;rs) - GetHigh(p-&gt;ls) == 2) {
				if (GetHigh(p-&gt;rs-&gt;rs) &gt;= GetHigh(p-&gt;rs-&gt;ls))
					RightPlus(p);
				else
					RightLeft(p);
			}
		}
		else if(p-&gt;data &lt; x) {
			Erase(p-&gt;rs, x), update(p);
			if (GetHigh(p-&gt;ls) - GetHigh(p-&gt;rs) == 2) {
				if (GetHigh(p-&gt;ls-&gt;ls) &gt;= GetHigh(p-&gt;ls-&gt;rs))
					LeftPlus(p);
				else
					LeftRight(p);
			}
		}
		else {
			if (p-&gt;freq &gt; 1) {
				--(p-&gt;freq);
				update(p);
				return;
			}
			if (p-&gt;ls &amp;&amp; p-&gt;rs) {
				AVLtree q = p-&gt;rs;
				while (q-&gt;ls) q = q-&gt;ls;
				p-&gt;freq = q-&gt;freq;
				p-&gt;data = q-&gt;data, q-&gt;freq = 1;
				Erase(p-&gt;rs, q-&gt;data);
				update(p);
				if (GetHigh(p-&gt;ls) - GetHigh(p-&gt;rs) == 2) {
					if (GetHigh(p-&gt;ls-&gt;ls) &gt;= GetHigh(p-&gt;ls-&gt;rs))
						LeftPlus(p);
					else
						LeftRight(p);
				}
			}
			else {
				AVLtree q = p;
				if (p-&gt;ls) p = p-&gt;ls;
				else if (p-&gt;rs) p = p-&gt;rs;
				else p = NULL;
				delete q;
				q = NULL;
			}
		}
		if (p == NULL) return;
		update(p);
	}
	inline void erase(int x) {
		Erase(root, x);
	}
	inline int get_val(AVLtree p, int rank) {
		if (GetSize(p-&gt;ls) &gt;= rank) return get_val(p-&gt;ls, rank);
		if (GetSize(p-&gt;ls) + p-&gt;freq &gt;= rank) return p-&gt;data;
		return get_val(p-&gt;rs, rank - GetSize(p-&gt;ls) - p-&gt;freq);
	}
	inline int GetVal(int rank) {
		return get_val(root, rank);
	}
	inline int get_rank(AVLtree p, int val) {
		if (p-&gt;data == val) return GetSize(p-&gt;ls) + 1;
		if (p-&gt;data &gt; val) return get_rank(p-&gt;ls, val);
		return get_rank(p-&gt;rs, val) + GetSize(p-&gt;ls) + p-&gt;freq;
	}
	inline int GetRank(int val) {
		return get_rank(root, val);
	}
	inline int GetPrev(int val) {
		AVLtree ans = new AVLnode(-1LL &lt;&lt; 42), p = root;
		while (p) {
			if (p-&gt;data == val) {
				if (p-&gt;ls) {
					p = p-&gt;ls;
					while (p-&gt;rs)
						p = p-&gt;rs;
					ans = p;
				}
				break;
			}
			if (p-&gt;data &lt; val &amp;&amp; p-&gt;data &gt; ans-&gt;data) ans = p;
			p = p-&gt;data &lt; val ? p-&gt;rs : p-&gt;ls;
		}
		return ans-&gt;data;
	}
	inline int GetNext(int val) {
		AVLtree ans = new AVLnode(1LL &lt;&lt; 42), p = root;
		while (p) {
			if (p-&gt;data == val) {
				if (p-&gt;rs) {
					p = p-&gt;rs;
					while (p-&gt;ls)
						p = p-&gt;ls;
					ans = p;
				}
				break;
			}
			if (p-&gt;data &gt; val &amp;&amp; p-&gt;data &lt; ans-&gt;data) ans = p;
			p = p-&gt;data &lt; val ? p-&gt;rs : p-&gt;ls;
		}
		return ans-&gt;data;
	}
};
int n, x, opt;
AVL a;
signed main() {
	read(n);
	for (int i = 1; i &lt;= n; ++i) {
		read(opt, x);
		switch(opt) {
			case 1: a.insert(x); break;
			case 2: a.erase(x); break;
			case 3: write(a.GetRank(x)), putchar(10); break;
			case 4: write(a.GetVal(x)), putchar(10); break;
			case 5: write(a.GetPrev(x)), putchar(10); break;
			case 6: write(a.GetNext(x)), putchar(10); break;
		}
	}
	return 0;
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%81%9A%E6%B3%95">做法：</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%8A%82%E7%82%B9%E5%AE%9A%E4%B9%89">基本的节点定义：</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E5%8F%8A%E6%9B%B4%E6%96%B0%E6%A0%91%E9%AB%98%E5%A4%A7%E5%B0%8F">获取及更新树高，大小：</a></li>
<li><a href="#%E5%B7%A6%E5%8F%B3%E6%97%8B%E8%BD%AC">左右旋转：</a>
<ul>
<li><a href="#%E5%B7%A6%E5%B7%A6">左左：</a></li>
<li><a href="#%E5%8F%B3%E5%8F%B3">右右：</a></li>
<li><a href="#%E5%B7%A6%E5%8F%B3%E5%8F%8A%E5%8F%B3%E5%B7%A6">左右及右左：</a></li>
</ul>
</li>
<li><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9C%AC%E9%A2%98%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BD%86%E5%8F%AF%E5%BD%93%E5%81%9A%E8%B0%83%E8%AF%95%E8%AF%AD%E5%8F%A5">中序遍历(本题不需要，但可当做调试语句)：</a></li>
<li><a href="#%E6%8F%92%E5%85%A5">插入：</a></li>
<li><a href="#%E5%88%A0%E9%99%A4">删除：</a></li>
<li><a href="#%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%80%BC%E6%89%BE%E6%8E%92%E5%90%8D">根据数值找排名：</a></li>
<li><a href="#%E6%A0%B9%E6%8D%AE%E6%8E%92%E5%90%8D%E6%89%BE%E6%95%B0%E5%80%BC">根据排名找数值：</a></li>
<li><a href="#%E6%89%BE%E5%89%8D%E9%A9%B1%E5%90%8E%E7%BB%A7">找前驱后继：</a></li>
<li><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%E6%B3%A8%E9%87%8A%E5%89%8D%E9%9D%A2%E6%9C%89%E4%BA%86%E5%B0%B1%E4%B8%8D%E5%86%99%E4%BA%86">完整代码如下(注释前面有了，就不写了)：</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://YCE3216037.github.io/post/ce-shi/">
              <h3 class="post-title">
                测试
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://YCE3216037.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
