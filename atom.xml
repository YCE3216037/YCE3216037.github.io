<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://YCE3216037.github.io</id>
    <title>Gridea</title>
    <updated>2020-04-17T10:24:41.841Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://YCE3216037.github.io"/>
    <link rel="self" href="https://YCE3216037.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://YCE3216037.github.io/images/avatar.png</logo>
    <icon>https://YCE3216037.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[洛谷 P2180 题解]]></title>
        <id>https://YCE3216037.github.io/post/luo-gu-p2180-ti-jie/</id>
        <link href="https://YCE3216037.github.io/post/luo-gu-p2180-ti-jie/">
        </link>
        <updated>2020-04-17T09:57:54.000Z</updated>
        <content type="html"><![CDATA[<p>题目链接：https://www.luogu.com.cn/problem/P2180</p>
<p>作为我A掉的第777题，我自然要写一篇题解庆祝一下的。<s>（我是不会告诉你我是因为再不写题解社区贡献分就要掉了才来写题解的）</s></p>
<p>有一篇题解是有说明的但是Markdown炸了且没lve有代码，另一篇有代码但是没有详细说明，我就来发这篇题解，来详（cu）细（lüe）地解释一下吧。</p>
<p>首先，要明确只有一行不为满的时候答案才可能为最大值，像这样：</p>
<pre><code>.......
...ooo.
.ooooo.
.ooooo.
.ooooo.
.......
</code></pre>
<p>显然要比</p>
<pre><code>.......
..oooo.
..oooo.
.ooooo.
.ooooo.
.......
</code></pre>
<p>更优。<br>
所以，只需要枚举一下放的行数就可以了。<br>
那么，如何计算一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>×</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\times b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的网格中，可以组成多少个矩形呢？显然，一行有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>×</mo><mo>(</mo><mi>a</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">a\times(a-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 种选法，一列中有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>×</mo><mo>(</mo><mi>b</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">b\times(b-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 种，所以有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>×</mo><mi>b</mi><mo>×</mo><mo>(</mo><mi>a</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>×</mo><mo>(</mo><mi>b</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">a\times b\times(a-1)\times(b-1)/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">4</span></span></span></span> 种方案。假设剩余的一行有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 列，那么还要加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>×</mo><mi>c</mi><mo>×</mo><mo>(</mo><mi>c</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">a\times c\times(c-1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，这样，正解就出来了，答案 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>=</mo><msubsup><mi>max</mi><mo>⁡</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo>)</mo></mrow></msubsup><mo>(</mo><mi>i</mi><mo>×</mo><mo>⌊</mo><mi>k</mi><mi mathvariant="normal">/</mi><mi>i</mi><mo>⌋</mo><mo>×</mo><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>×</mo><mo>(</mo><mo>⌊</mo><mi>k</mi><mi mathvariant="normal">/</mi><mi>i</mi><mo>⌋</mo><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>4</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">ans=\max\limits _{i=1}^{\min(n,k)}(i\times \lfloor k/i\rfloor \times(i-1)\times(\lfloor k/i\rfloor-1)/4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.0692239999999997em;vertical-align:-0.727664em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3415599999999999em;"><span style="top:-2.072336em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">max</span></span></span><span style="top:-3.41656em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight">min</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.727664em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord mathdefault">i</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord mathdefault">i</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">4</span><span class="mclose">)</span></span></span></span>。<br>
最后，有一个非常坑的地方，就是当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n&gt;m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 要交换，否则只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>90</mn></mrow><annotation encoding="application/x-tex">90</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">0</span></span></span></span> 分。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define ll long long
using namespace std;
FILE *fin, *fout;
inline int read(ll &amp;x) {
	char c = 0; int f = x = 0;
	while (c &lt; 48 || c &gt; 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c &gt; 47 &amp;&amp; c &lt; 58) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c &amp; 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
template&lt;class T, class... Args&gt; inline int read(T &amp;x, Args&amp;... args) {
	return read(x) + read(args...);
}
inline int write(ll x) {
	if (x &lt; 0) return fputc(45, fout), write(-x);
	if (x &gt; 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
ll n, m, k, ans;
int main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen(&quot;P2180.in&quot;, &quot;rb&quot;);
	fout = fopen(&quot;P2180.out&quot;, &quot;wb&quot;);
	#endif
	read(n, m, k); if (n &gt; m) swap(n, m);//就是这个地方，非常坑！
	for (ll i = 1; i &lt;= min(n, k); ++i) {
		ll x = k / i, y = k % i;
		if (!y &amp;&amp; x &gt; m) continue;
		if (y &amp;&amp; x &gt;= m) continue;
		ans = max(ans, i * x * (i - 1) * (x - 1) / 4 + x * y * (y - 1) / 2);
	}
	write(ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洛谷 P6248 题解]]></title>
        <id>https://YCE3216037.github.io/post/luo-gu-p6248-ti-jie/</id>
        <link href="https://YCE3216037.github.io/post/luo-gu-p6248-ti-jie/">
        </link>
        <updated>2020-03-28T11:38:43.000Z</updated>
        <content type="html"><![CDATA[<p>题目链接：https://www.luogu.com.cn/problem/P6248</p>
<p>这道题目是一个搜索题，数据范围很小，但是不可以直接暴搜，否则直接 TLE，但是由于题目说选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span> 个人，所以可以略加剪枝，时间复杂度从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">2^n\times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 转为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mn>6</mn></msubsup><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">C_n^6\times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 了，可以通过本题。输入的名字可以用 map 存起来，而且可以利用位运算省去回溯。</p>
<pre><code class="language-cpp">#include&lt;map&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 30 + 10;
FILE *fin, *fout;
inline int read(int &amp;x) {
	char c = 0; int f = x = 0;
	while (c &lt; 48 || c &gt; 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c &gt; 47 &amp;&amp; c &lt; 58) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c &amp; 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
inline int read(string &amp;s) {
	s = &quot;&quot;; char c = 0;
	while (c == 32 || c == 10 || c == 13 || c == 0) c = fgetc(fin); if (c == -1) return 0;
	while (!(c == 32 || c == 10 || c == 13 || c == 0 || c == -1)) s += c, c = fgetc(fin);
	return 1;
}
template&lt;class T, class... Args&gt; inline int read(T &amp;x, Args&amp;... args) {
	return read(x) + read(args...);
}
inline int write(int x) {
	if (x &lt; 0) return fputc(45, fout), write(-x);
	if (x &gt; 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
string name, u, v;
map&lt;string, int&gt; ma;//ma[s]表示名字为s的人的下标
int n, m, ans, a[N], k[N], gay[N];//a[i]表示第i个人的初始实力，k[i]表示第i对人新增的实力，gay[i]表示第i对人的两个下标，从0开始，例如10(1010)表示1号和3号可以新增实力
void dfs(int x, int y, int res, int bit) {//x表示现在到了第x个人，y表示选择了y个人，res表示目前的总实力，bit表示选择的人，例如22(10110)表示选择了1、2、4号
	if (n - x + y &lt; 6) return;//要是到结尾都不能选够6个人，直接返回
	if (y == 6) {//如果选择了6个人了
		for (int i = 0; i &lt; m; ++i)//每个gay都枚举一遍
			if ((bit &amp; gay[i]) == gay[i])
				res += k[i];
		ans = max(ans, res);
		return;
	}
	if (x == n) return;
	dfs(x + 1, y, res, bit);//不选
	dfs(x + 1, y + 1, res + a[x], bit | (1 &lt;&lt; x));//选，或上第x个人
}
int main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen(&quot;P6248.in&quot;, &quot;rb&quot;);
	fout = fopen(&quot;P6248.out&quot;, &quot;wb&quot;);
	#endif
	read(n, m);
	for (int i = 0; i &lt; n; ++i) read(name, a[i]), ma[name] = i;//用map存下名字
	for (int i = 0; i &lt; m; ++i) read(u, v, k[i]), gay[i] = (1 &lt;&lt; ma[u]) | (1 &lt;&lt; ma[v]);//将两个人绑在一起
	dfs(0, 0, 0, 0);
	write(ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洛谷 P6205 题解]]></title>
        <id>https://YCE3216037.github.io/post/luo-gu-p6205-ti-jie/</id>
        <link href="https://YCE3216037.github.io/post/luo-gu-p6205-ti-jie/">
        </link>
        <updated>2020-03-17T12:27:23.000Z</updated>
        <content type="html"><![CDATA[<p>推销一下我的新博客：https://yce3216037.github.io/post/luo-gu-p6205-ti-jie/</p>
<p>这道题目一看，就是一道背包裸题，用完全背包的方法求方案数即可，我以为开了LL就不会见祖宗了，我就写了这样的代码：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#define ll long long
using namespace std;
const int N = 1000 + 10;
FILE *fin, *fout;
inline int read(ll &amp;x) {//快读
	char c = 0; int f = x = 0;
	while (c &lt; 48 || c &gt; 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c &gt; 47 &amp;&amp; c &lt; 58) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c &amp; 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
template&lt;class T, class... Args&gt; inline int read(T &amp;x, Args&amp;... args) {
	return read(x) + read(args...);
}
inline int write(ll x) {//快写
	if (x &lt; 0) return fputc(45, fout), write(-x);
	if (x &gt; 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
ll n, k, dp[N];
int main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen(&quot;P6205.in&quot;, &quot;rb&quot;);
	fout = fopen(&quot;P6205.out&quot;, &quot;wb&quot;);
	#endif
	read(n, k), dp[0] = 1;
	for (ll i = 1; i &lt;= k; ++i)//完全背包模板，v[i]=i,w[i]=i
		for (ll j = i; j &lt;= n; ++j)
			dp[j] += dp[j - i];
	write(dp[n]);
	return 0;
}
</code></pre>
<p>WTF？70分？看来不开高精见祖宗了，我为了图卡常，于是写了一个万进制的压位高精！</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N = 1000 + 10;
const int base = 10000;
FILE *fin, *fout;
struct bigint {
	int a[11];
	bigint(){memset(a, 0, sizeof(a)), a[0] = 1;}//初始化
	inline int&amp; operator [](int n) {
		return a[n];
	}
	inline bigint&amp; operator =(int x) {
		a[0] = 0; if (!x) return a[0] = 1, *this;
		while (x) a[++a[0]] = x % base, x /= base;
		return *this;
	}
	inline friend bigint operator +(bigint a, bigint b) {//两个数相加
		if (b[0] &gt; a[0]) a[0] = b[0];
		for (int i = 1; i &lt;= a[0]; ++i) a[i] += b[i];
		for (int i = 1; i &lt;= a[0]; ++i) if (a[i] &gt;= base) a[i] -= base, ++a[i + 1];
		if (a[a[0] + 1]) ++a[0]; return a;
	}
	inline friend bigint&amp; operator +=(bigint&amp; a, bigint b) {
		return a = a + b;
	}
};
inline int read(int &amp;x) {
	char c = 0; int f = x = 0;
	while (c &lt; 48 || c &gt; 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c &gt; 47 &amp;&amp; c &lt; 58) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c &amp; 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
template&lt;class T, class... Args&gt; inline int read(T &amp;x, Args&amp;... args) {
	return read(x) + read(args...);
}
inline int write(bigint x) {
	fprintf(fout, &quot;%d&quot;, x[x[0]]);
	for (int i = x[0] - 1; i; --i)
		fprintf(fout, &quot;%04d&quot;, x[i]);
	return 1;
}
int n, k;
bigint dp[N];
int main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen(&quot;P6205.in&quot;, &quot;rb&quot;);
	fout = fopen(&quot;P6205.out&quot;, &quot;wb&quot;);
	#endif
	read(n, k), dp[0] = 1;
	for (int i = 1; i &lt;= k; ++i)
		for (int j = i; j &lt;= n; ++j)
			dp[j] += dp[j - i];
	write(dp[n]);
	return 0;
}
</code></pre>
<p>于是就A了。当然，也可一用<code>__int128</code>来水，但是，只要数据范围拓展至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>≤</mo><mn>2000</mn></mrow><annotation encoding="application/x-tex">N\le2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，<code>__int128</code>就炸了，而我的高精度只需要改一点就可以继续使用了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洛谷 P6200 题解]]></title>
        <id>https://YCE3216037.github.io/post/luo-gu-p6200-ti-jie/</id>
        <link href="https://YCE3216037.github.io/post/luo-gu-p6200-ti-jie/">
        </link>
        <updated>2020-03-17T12:26:54.000Z</updated>
        <content type="html"><![CDATA[<p>推销一下我的新博客：https://yce3216037.github.io/post/luo-gu-p6200-ti-jie/</p>
<p>这道题就是一道水题，就是说有多少个点，使得在它的正北，正南，正东，正西，东北，东南，西北，西南和该点所连的直线能覆盖所有点，直接枚举每一个点，然后看一下这个点是否合法即可，时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="代码如下">代码如下：</h3>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
const int N = 100 + 10;
FILE *fin, *fout;
inline int read(int &amp;x) {
	char c = 0; int f = x = 0;
	while (c &lt; 48 || c &gt; 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c &gt; 47 &amp;&amp; c &lt; 58) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c &amp; 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
template&lt;class T, class... Args&gt; inline int read(T &amp;x, Args&amp;... args) {
	return read(x) + read(args...);
}
inline int write(int x) {
	if (x &lt; 0) return fputc(45, fout), write(-x);
	if (x &gt; 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
int n, k, x, y, ans, vis[N][N];//vis[i][j]表示第i行第j列的位置有几个对手
inline void work(int x, int y) {
	int res = vis[x][y], temp = vis[x][y]; vis[x][y] = 0;//这个地方的vis[x][y]要先清零，否则可能会被算多次
	for (int i = 1; i &lt;= n; ++i) res += vis[x][i];
	for (int i = 1; i &lt;= n; ++i) res += vis[i][y];
	for (int i = x + 1, j = y + 1; i &lt;= n &amp;&amp; j &lt;= n; ++i, ++j) res += vis[i][j];
	for (int i = x - 1, j = y + 1; i &amp;&amp; j &lt;= n; --i, ++j) res += vis[i][j];
	for (int i = x - 1, j = y - 1; i &amp;&amp; j; --i, --j) res += vis[i][j];
	for (int i = x + 1, j = y - 1; i &lt;= n &amp;&amp; j; ++i, --j) res += vis[i][j];
    //8个方向的对手数量
	if (res == k) ++ans; vis[x][y] = temp;//别忘记加回来
}
int main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen(&quot;P6200.in&quot;, &quot;rb&quot;);
	fout = fopen(&quot;P6200.out&quot;, &quot;wb&quot;);
	#endif
	read(n, k);
	for (int i = 1; i &lt;= k; ++i) read(x, y), ++vis[x][y];
	for (int i = 1; i &lt;= n; ++i)
		for (int j = 1; j &lt;= n; ++j)
			work(i, j);//枚举每一个点即可
	write(ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洛谷 P6182 题解]]></title>
        <id>https://YCE3216037.github.io/post/luo-gu-p6182-ti-jie/</id>
        <link href="https://YCE3216037.github.io/post/luo-gu-p6182-ti-jie/">
        </link>
        <updated>2020-03-17T12:26:16.000Z</updated>
        <content type="html"><![CDATA[<p>推销一下我的新博客（但图片可能显示不了）：https://yce3216037.github.io/post/luo-gu-p6182-ti-jie/</p>
<p>本人想看一下洛谷新增的题目，结果就被我切了，而且是本题首A。如果这一道题只有前两个操作，那么这道题目就是一道很水的模拟题，直接用栈就可以了。然而，有了第三个操作，那么就有点难了，这个我称它为“可持久化栈”。有一种朴素的做法，就是在前两个操作的时候，直接复制上一次的栈的结果，遇到第三种操作，就复制第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次操作的结果，因为说的是第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 次操作前，而不是第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 次操作后，这样，样例模拟如下（为了方便，一开始来一个编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 的奶牛）：</p>
<pre><code>0 ：-1
1 ：-1 5
2 ：-1 5 3
3 ：-1 5 3 7
4 ：-1 5 3
5 ：-1 5
6 ：-1 5 2
7 ：-1 5 3 7
8 ：-1 5 3 7 4
9 ：-1 5 3 7
10：-1 5 2
11：-1 5
12：-1
</code></pre>
<p>但是，这样操作的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，空间复杂度也为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>8</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">n\le 8\times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> 的数据来说，不管从时间还是从空间上来说，都会炸，所以，需要有一个更优的方法。这就要用到我新创的“可持久化栈”了。</p>
<p>如何实现这个“可持久化栈”呢？我画一个图来模拟一下（图略丑，且有点多，见谅），由于我是先画完再截图的，所以会有多余的线段：</p>
<p>初始状态（这时候为了减少边界条件判断，还需要再加一个虚拟奶牛，编号任意）：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/ot01my7n.png" alt="" loading="lazy"><br>
第1步，插入5号奶牛，直接在上一次的操作后添加一头5号奶牛即可：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/ffzn8xsd.png" alt="" loading="lazy"><br>
第2步，插入3号奶牛，和第1步类似：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/m4fro19g.png" alt="" loading="lazy"><br>
第3步，插入7号奶牛，和第1步类似：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/bgbelfzn.png" alt="" loading="lazy"><br>
第4步，去掉7号奶牛，将在上一次操作的倒数第二头奶牛加在该奶牛的前一个奶牛后面，这样即可去掉最后一头奶牛：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/m860k1tu.png" alt="" loading="lazy"><br>
第5步，回到第4次操作前，将第2次操作后的队尾的奶牛加在该奶牛的前一个奶牛后面，即可忽略2至4步：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/4modz3tq.png" alt="" loading="lazy"><br>
第6步，插入2号奶牛，和第1步类似：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/cf1qgdta.png" alt="" loading="lazy"><br>
第7步，回到第4次操作前，和第5步类似：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/2tkhpdi3.png" alt="" loading="lazy"><br>
第8步，插入4号奶牛，和第1步类似：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/z9bnor14.png" alt="" loading="lazy"><br>
第9步，去掉4号奶牛，和第4步类似：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/kgoq0fb9.png" alt="" loading="lazy"><br>
第10步，回到第7次操作前，和第5步类似：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/42lyi87t.png" alt="" loading="lazy"><br>
第11步，去掉2号奶牛，和第4步类似：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/kd0dj7gt.png" alt="" loading="lazy"><br>
第12步，去掉5号奶牛，和第4步类似：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/its7pw3n.png" alt="" loading="lazy"><br>
由于我想<s>给大家介绍一下指针版如何实现</s>装X，我写一个指针版的。</p>
<h3 id="代码如下">代码如下：</h3>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
const int N = 80000 + 10;
FILE *fin, *fout;
inline int read(int &amp;x) {//快读
	char c = 0; int f = x = 0;
	while (c &lt; 48 || c &gt; 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c &gt; 47 &amp;&amp; c &lt; 58) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c &amp; 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
inline int read(char &amp;c) {
	c = 0; while (c == 32 || c == 10 || c == 13 || c == 0) c = fgetc(fin);
	if (c == -1) return 0; return 1;
}
inline int write(int x) {//快写
	if (x &lt; 0) return fputc(45, fout), write(-x);
	if (x &gt; 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
inline int write(char c) {
	return fputc(c, fout), 1;
}
template&lt;class T, class... Args&gt; inline int write(T x, Args... args) {
	return write(x) + write(args...);
}
struct node;
typedef node* list;//接下来写起来方便
struct node {
	int val; list last;//val为奶牛的编号，last为上一头奶牛的位置
	node(int val = 0, list last = 0): val(val), last(last){}//构造函数
};
char opt;
int n, x;
list a[N];
int main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen(&quot;P6182.in&quot;, &quot;rb&quot;);
	fout = fopen(&quot;P6182.out&quot;, &quot;wb&quot;);
	#endif
	a[0] = new node(3216037), a[read(n)] = new node(-1, a[0]), ++n;//a[0]甚至可以用1******7代替，read(n)的返回值为1，这里简写
	for (int i = 2; i &lt;= n; ++i) {//为了方便操作，将n加1，并且i从2开始
		read(opt);
		if (opt == 's') a[i] = new node(a[i - 1]-&gt;last-&gt;val, a[i - 1]-&gt;last-&gt;last);//删除
		else {
			read(x); if (opt == 'a') a[i] = new node(x, a[i - 1]);//插入
			else a[i] = new node(a[x]-&gt;val, a[x]-&gt;last);//可持久化
		}
		write(a[i]-&gt;val, '\n');
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洛谷 P5737 题解]]></title>
        <id>https://YCE3216037.github.io/post/luo-gu-p5737-ti-jie/</id>
        <link href="https://YCE3216037.github.io/post/luo-gu-p5737-ti-jie/">
        </link>
        <updated>2020-03-17T12:25:49.000Z</updated>
        <content type="html"><![CDATA[<p>其实我是来推销我的新博客的（感谢@rui_er）：https://yce3216037.github.io/post/luo-gu-p5737-ti-jie/</p>
<p>这道题目相信大家一点会有一个思路，就是直接一年一年的判断闰年，函数如下：</p>
<pre><code class="language-cpp">inline bool judge(int x) {
    if (x % 4) return 0;
    if (!(x % 100) &amp;&amp; x % 400) return 0;
    return 1;
}
</code></pre>
<p>但是，事实上，不需要一年一年的判断，因为只有4的倍数的年份才可能为闰年，所以可以4年4年判断，注意当这一年为100的倍数但不是400的倍数时，这年不是闰年。</p>
<h3 id="代码如下">代码如下：</h3>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
using namespace std;
const int N = 3000 + 10;
FILE *fin, *fout;
inline int read(int &amp;x) {//快读（虽然没什么用）
	char c = 0; int f = x = 0;
	while (c &lt; 48 || c &gt; 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c &gt; 47 &amp;&amp; c &lt; 58) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c &amp; 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
template&lt;class T, class... Args&gt; inline int read(T &amp;x, Args&amp;... args) {
	return read(x) + read(args...);
}
inline int write(int x) {
	if (x &lt; 0) return fputc(45, fout), write(-x);
	if (x &gt; 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
inline int write(char c) {
	return fputc(c, fout), 1;
}
template&lt;class T, class... Args&gt; inline int write(T x, Args... args) {
	return write(x) + write(args...);
}
int l, r, cnt, a[N];
signed main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen(&quot;P5737.in&quot;, &quot;rb&quot;);
	fout = fopen(&quot;P5737.out&quot;, &quot;wb&quot;);
	#endif
	read(l, r);
	while (l &amp; 3) ++l;//让l成为4的倍数
	while (l &lt;= r) {//如果l&gt;r了，就直接跳出循环
		if (!(l % 100) &amp;&amp; l % 400) {
			l += 4;
			continue;
		}
		a[++cnt] = l, l += 4;
	}
	write(cnt, '\n');
	for (int i = 1; i &lt;= cnt; ++i) write(a[i], ' ');
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洛谷 P6136 题解]]></title>
        <id>https://YCE3216037.github.io/post/luo-gu-p6136-ti-jie/</id>
        <link href="https://YCE3216037.github.io/post/luo-gu-p6136-ti-jie/">
        </link>
        <updated>2020-03-17T12:25:15.000Z</updated>
        <content type="html"><![CDATA[<p>首先，推销一下我的新博客：https://yce3216037.github.io/post/luo-gu-p6136-ti-jie</p>
<p>这道题目怎么能没有AVL树呢？其实，在P3369，我就写了一篇AVL树的题解，链接在这里（第二篇可能没有图片，见谅），我就不再赘述了：<br>
https://www.luogu.com.cn/blog/YCE-22/solution-p3369<br>
https://yce3216037.github.io/post/luo-gu-p3369-ti-jie</p>
<p>唯一需要注意的是，要找排名的数不一定有，所以还需要增加一个查找函数，代码如下：</p>
<pre><code class="language-cpp">inline AVLtree Find(AVLtree&amp; p, int x) {
	if (!p) return NULL;//找不到就返回空，否则就返回地址
	if (p-&gt;data == x) return p;
	if (p-&gt;data &gt; x) return Find(p-&gt;ls, x);
	return Find(p-&gt;rs, x);
}
inline AVLtree find(int x) {
	return Find(root, x);
}
</code></pre>
<p>如果找不到这个数，就将这个数改为它的后继，所以，还需要预先加一个极大值来保证能过找到这个排名。</p>
<h3 id="代码如下">代码如下：</h3>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define int long long
using namespace std;
FILE *fin, *fout;
inline int read(int &amp;x) {//快读，这题常数优化很重要
	char c = 0; int f = x = 0;
	while (c &lt; 48 || c &gt; 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c &gt; 47 &amp;&amp; c &lt; 58) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c &amp; 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
template&lt;class T, class... Args&gt; inline int read(T &amp;x, Args&amp;... args) {
	return read(x) + read(args...);
}
inline int write(int x) {
	if (x &lt; 0) return fputc(45, fout), write(-x);
	if (x &gt; 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
struct AVLnode;
typedef AVLnode* AVLtree;
struct AVLnode {//这个部分在之前P3369中的题解已经详细讲述了，这里我就不写注释了。
	int data, high;
	int freq, size;
	AVLtree ls, rs;
	AVLnode(): data(0), high(1), freq(1), size(1), ls(NULL), rs(NULL){}
	AVLnode(int a): data(a), high(1), freq(1), size(1), ls(NULL), rs(NULL){}
};
inline int GetSize(AVLtree p) {
	if (p == NULL) return 0;
	return p-&gt;size;
}
inline int GetHigh(AVLtree p) {
	if (p == NULL) return 0;
	return p-&gt;high;
}
struct AVL {
	AVLtree root;
	inline void update(AVLtree&amp; p) {
		p-&gt;size = GetSize(p-&gt;ls) + GetSize(p-&gt;rs) + p-&gt;freq;
		p-&gt;high = max(GetHigh(p-&gt;ls), GetHigh(p-&gt;rs)) + 1;
	}
	inline void LeftPlus(AVLtree&amp; p) {
		AVLtree q;
		q = p-&gt;ls;
		p-&gt;ls = q-&gt;rs;
		q-&gt;rs = p;
		update(p);
		update(q);
		p = q;
	}
	inline void RightPlus(AVLtree&amp; p) {
		AVLtree q;
		q = p-&gt;rs;
		p-&gt;rs = q-&gt;ls;
		q-&gt;ls = p;
		update(p);
		update(q);
		p = q;
	}
	inline void LeftRight(AVLtree&amp; p) {
		RightPlus(p-&gt;ls);
		LeftPlus(p);
	}
	inline void RightLeft(AVLtree&amp; p) {
		LeftPlus(p-&gt;rs);
		RightPlus(p);
	}
	inline void Insert(AVLtree &amp;p, int x) {
		if (p == NULL) {
			p = new AVLnode(x);
			return;
		}
		if (p-&gt;data == x) {
			++(p-&gt;freq);
			update(p);
			return;
		}
		if (p-&gt;data &gt; x) {
			Insert(p-&gt;ls, x), update(p);
			if (GetHigh(p-&gt;ls) - GetHigh(p-&gt;rs) == 2) {
				if (x &lt; p-&gt;ls-&gt;data)
					LeftPlus(p);
				else
					LeftRight(p);
			}
		}
		else {
			Insert(p-&gt;rs, x), update(p);
			if (GetHigh(p-&gt;rs) - GetHigh(p-&gt;ls) == 2) {
				if (x &gt; p-&gt;rs-&gt;data)
					RightPlus(p);
				else
					RightLeft(p);
			}
		}
		update(p);
	}
	inline void insert(int x) {
		Insert(root, x);
	}
	inline AVLtree Find(AVLtree&amp; p, int x) {//只不过多了一个查找操作
		if (!p) return NULL;
		if (p-&gt;data == x) return p;
		if (p-&gt;data &gt; x) return Find(p-&gt;ls, x);
		return Find(p-&gt;rs, x);
	}
	inline AVLtree find(int x) {
		return Find(root, x);
	}
	inline void Erase(AVLtree&amp; p, int x) {
		if (p == NULL) return;
		if (p-&gt;data &gt; x) {
			Erase(p-&gt;ls, x), update(p);
			if (GetHigh(p-&gt;rs) - GetHigh(p-&gt;ls) == 2) {
				if (GetHigh(p-&gt;rs-&gt;rs) &gt;= GetHigh(p-&gt;rs-&gt;ls))
					RightPlus(p);
				else
					RightLeft(p);
			}
		}
		else if(p-&gt;data &lt; x) {
			Erase(p-&gt;rs, x), update(p);
			if (GetHigh(p-&gt;ls) - GetHigh(p-&gt;rs) == 2) {
				if (GetHigh(p-&gt;ls-&gt;ls) &gt;= GetHigh(p-&gt;ls-&gt;rs))
					LeftPlus(p);
				else
					LeftRight(p);
			}
		}
		else {
			if (p-&gt;freq &gt; 1) {
				--(p-&gt;freq);
				update(p);
				return;
			}
			if (p-&gt;ls &amp;&amp; p-&gt;rs) {
				AVLtree q = p-&gt;rs;
				while (q-&gt;ls) q = q-&gt;ls;
				p-&gt;freq = q-&gt;freq;
				p-&gt;data = q-&gt;data, q-&gt;freq = 1;
				Erase(p-&gt;rs, q-&gt;data);
				update(p);
				if (GetHigh(p-&gt;ls) - GetHigh(p-&gt;rs) == 2) {
					if (GetHigh(p-&gt;ls-&gt;ls) &gt;= GetHigh(p-&gt;ls-&gt;rs))
						LeftPlus(p);
					else
						LeftRight(p);
				}
			}
			else {
				AVLtree q = p;
				if (p-&gt;ls) p = p-&gt;ls;
				else if (p-&gt;rs) p = p-&gt;rs;
				else p = NULL;
				delete q;
				q = NULL;
			}
		}
		if (p == NULL) return;
		update(p);
	}
	inline void erase(int x) {
		Erase(root, x);
	}
	inline int get_val(AVLtree p, int rank) {
		if (GetSize(p-&gt;ls) &gt;= rank) return get_val(p-&gt;ls, rank);
		if (GetSize(p-&gt;ls) + p-&gt;freq &gt;= rank) return p-&gt;data;
		return get_val(p-&gt;rs, rank - GetSize(p-&gt;ls) - p-&gt;freq);
	}
	inline int GetVal(int rank) {
		return get_val(root, rank);
	}
	inline int get_rank(AVLtree p, int val) {
		if (p-&gt;data == val) return GetSize(p-&gt;ls) + 1;
		if (p-&gt;data &gt; val) return get_rank(p-&gt;ls, val);
		return get_rank(p-&gt;rs, val) + GetSize(p-&gt;ls) + p-&gt;freq;
	}
	inline int GetRank(int val) {
		return get_rank(root, val);
	}
	inline int GetPrev(int val) {
		AVLtree ans = new AVLnode(-1LL &lt;&lt; 42), p = root;
		while (p) {
			if (p-&gt;data == val) {
				if (p-&gt;ls) {
					p = p-&gt;ls;
					while (p-&gt;rs)
						p = p-&gt;rs;
					ans = p;
				}
				break;
			}
			if (p-&gt;data &lt; val &amp;&amp; p-&gt;data &gt; ans-&gt;data) ans = p;
			p = p-&gt;data &lt; val ? p-&gt;rs : p-&gt;ls;
		}
		return ans-&gt;data;
	}
	inline int GetNext(int val) {
		AVLtree ans = new AVLnode(1LL &lt;&lt; 42), p = root;
		while (p) {
			if (p-&gt;data == val) {
				if (p-&gt;rs) {
					p = p-&gt;rs;
					while (p-&gt;ls)
						p = p-&gt;ls;
					ans = p;
				}
				break;
			}
			if (p-&gt;data &gt; val &amp;&amp; p-&gt;data &lt; ans-&gt;data) ans = p;
			p = p-&gt;data &lt; val ? p-&gt;rs : p-&gt;ls;
		}
		return ans-&gt;data;
	}
};
AVL a;
int n, m, x, opt, last, ans;
signed main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen(&quot;P6136.in&quot;, &quot;rb&quot;);
	fout = fopen(&quot;P6136.out&quot;, &quot;wb&quot;);
	#endif
	read(n, m), a.insert(1LL &lt;&lt; 42);//极大值先插入
	for (int i = 1; i &lt;= n; ++i) read(x), a.insert(x);//边读入边插入
	for (int i = 1; i &lt;= m; ++i) {
		read(opt, x), x ^= last;//输入经过加密，要先解密
		switch(opt) {
			case 1: a.insert(x); break;
			case 2: a.erase(x); break;
			case 3:
				if (!a.find(x)) x = a.GetNext(x);//如果找不到，就改为后继
				last = a.GetRank(x), ans ^= last; break;
			case 4: last = a.GetVal(x), ans ^= last; break;
			case 5: last = a.GetPrev(x), ans ^= last; break;
			case 6: last = a.GetNext(x), ans ^= last; break;
		}
	}
	write(ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[洛谷 P3369 题解]]></title>
        <id>https://YCE3216037.github.io/post/luo-gu-p3369-ti-jie/</id>
        <link href="https://YCE3216037.github.io/post/luo-gu-p3369-ti-jie/">
        </link>
        <updated>2020-03-17T12:23:57.000Z</updated>
        <content type="html"><![CDATA[<p>什么？！21页题解竟然没有一个人写 AVL 树，于是本蒟蒻就写一篇 AVL 树的题解。当然， AVL 树可能会比较难，而且常数较大，但如果有比较多的插入和删除 AVL 树就会有优势。</p>
<p>我们都知道，普通的二叉搜索树的插入、删除、查找期望时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，但在特殊构造的数据中时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，如图所示。<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/oyvfpmtu.png" alt="" loading="lazy"></p>
<p>但是，AVL 树有一个性质，就是两棵子树的高度差的绝对值不超过1，所以期望时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，最坏情况下时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msub><mi>log</mi><mo>⁡</mo><mi>ϕ</mi></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log_\phi n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.130248em;vertical-align:-0.380248em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2419679999999999em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">ϕ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.380248em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，如图所示。<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/acgb6w38.png" alt="" loading="lazy"><br>
由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>log</mi><mo>⁡</mo><mi>ϕ</mi></msub><mn>2</mn><mo>=</mo><mn>1.44</mn></mrow><annotation encoding="application/x-tex">\log_\phi2=1.44</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0746879999999999em;vertical-align:-0.380248em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2419679999999999em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">ϕ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.380248em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">4</span><span class="mord">4</span></span></span></span>，所以最坏情况的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msubsup><mi>log</mi><mo>⁡</mo><mn>2</mn><mn>1.44</mn></msubsup><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log_2^{1.44} n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.148448em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-2.4530000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">4</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，时间复杂度不高。</p>
<h2 id="做法">做法：</h2>
<h3 id="基本的节点定义">基本的节点定义：</h3>
<pre><code class="language-cpp">struct AVLnode;
typedef AVLnode* AVLtree;
struct AVLnode {
	int data, high;//权值，树高
	int freq, size;//频数，大小
	AVLtree ls, rs;//左子，右子
	AVLnode(): data(0), high(1), freq(1), size(1), ls(NULL), rs(NULL){}
	AVLnode(int a): data(a), high(1), freq(1), size(1), ls(NULL), rs(NULL){}//初始化
};
</code></pre>
<h3 id="获取及更新树高大小">获取及更新树高，大小：</h3>
<p>为了防止因访问空节点而导致 RE，所以要特定函数来获取及更新</p>
<pre><code class="language-cpp">inline int GetSize(AVLtree p) {//获取大小
	if (p == NULL) return 0;
	return p-&gt;size;
}
inline int GetHigh(AVLtree p) {//获取树高
	if (p == NULL) return 0;
	return p-&gt;high;
}
inline void update(AVLtree&amp; p) {//更新节点
	p-&gt;size = GetSize(p-&gt;ls) + GetSize(p-&gt;rs) + p-&gt;freq;
	p-&gt;high = max(GetHigh(p-&gt;ls), GetHigh(p-&gt;rs)) + 1;
}
</code></pre>
<h3 id="左右旋转">左右旋转：</h3>
<p>AVL 树的旋转方式有四种：左左，右右，左右，右左。</p>
<h4 id="左左">左左：</h4>
<p>假如有这样一颗二叉树，如图所示。<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/l3bpc4yd.png" alt="" loading="lazy"><br>
现在要插入21，则步骤如下（注意右下角的字）:<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/em7a9m63.png" alt="" loading="lazy"><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/4xftqv65.png" alt="" loading="lazy"><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/572my7q3.png" alt="" loading="lazy"></p>
<pre><code class="language-cpp">inline void LeftPlus(AVLtree&amp; p) {
	AVLtree q;
	q = p-&gt;ls;
	p-&gt;ls = q-&gt;rs;
	q-&gt;rs = p;
	update(p);
	update(q);
	p = q;
}
</code></pre>
<h4 id="右右">右右：</h4>
<p>假如有这样一颗二叉树，如图所示。<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/oe4z8x9a.png" alt="" loading="lazy"><br>
现在要插入55，则步骤如下：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/gq9ads9c.png" alt="" loading="lazy"><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/xlguww6z.png" alt="" loading="lazy"><br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/1mrcjdku.png" alt="" loading="lazy"></p>
<pre><code class="language-cpp">inline void RightPlus(AVLtree&amp; p) {
	AVLtree q;
	q = p-&gt;rs;
	p-&gt;rs = q-&gt;ls;
	q-&gt;ls = p;
	update(p);
	update(q);
	p = q;
}
</code></pre>
<h4 id="左右及右左">左右及右左：</h4>
<p>左右要先把这颗二叉树向右旋转变成左左，再左旋；右左反之。</p>
<pre><code class="language-cpp">inline void LeftRight(AVLtree&amp; p) {//左右
	RightPlus(p-&gt;ls);
	LeftPlus(p);
}
inline void RightLeft(AVLtree&amp; p) {//右左
	LeftPlus(p-&gt;rs);
	RightPlus(p);
}
</code></pre>
<h3 id="中序遍历本题不需要但可当做调试语句">中序遍历(本题不需要，但可当做调试语句)：</h3>
<pre><code class="language-cpp">inline void OutPut(AVLtree p) {
	if (p == NULL) return;
	OutPut(p-&gt;ls);
	for (int i = 1; i &lt;= p-&gt;freq; ++i)
		write(p-&gt;data), putchar(32);
	OutPut(p-&gt;rs);
}
inline void output() {//主程序可以更简洁，下同
	OutPut(root);
}
</code></pre>
<h3 id="插入">插入：</h3>
<p>先按照普通二叉搜索树的方式插入，再进行调整。</p>
<pre><code class="language-cpp">inline void Insert(AVLtree &amp;p, int x) {
	if (p == NULL) {
		p = new AVLnode(x);//没有这个节点，直接插入一个
		return;
	}
	if (p-&gt;data == x) {//如果已经有这个树了，直接增加这个数的频率，更新这个节点即可
		++(p-&gt;freq);
		update(p);
		return;
	}
	if (p-&gt;data &gt; x) {//往左子树插入，左子树可能偏高
		Insert(p-&gt;ls, x), update(p);
		if (GetHigh(p-&gt;ls) - GetHigh(p-&gt;rs) == 2) {
			if (x &lt; p-&gt;ls-&gt;data)
				LeftPlus(p);//左左
			else
				LeftRight(p);//左右
		}
	}
	else {//往右子树插入，右子树可能偏高
		Insert(p-&gt;rs, x), update(p);
		if (GetHigh(p-&gt;rs) - GetHigh(p-&gt;ls) == 2) {
			if (x &gt; p-&gt;rs-&gt;data)
				RightPlus(p);//右右
			else
				RightLeft(p);//右左
		}
	}
	update(p);//别忘记更新
}
inline void insert(int x) {
	Insert(root, x);
}
</code></pre>
<h3 id="删除">删除：</h3>
<p>先按照普通二叉搜索树的方式删除，再进行调整。</p>
<pre><code class="language-cpp">inline void Erase(AVLtree&amp; p, int x) {
	if (p == NULL) return;//找不到这个树，直接返回
	if (p-&gt;data &gt; x) {//删左子树的数，右子树可能偏高
		Erase(p-&gt;ls, x), update(p);
		if (GetHigh(p-&gt;rs) - GetHigh(p-&gt;ls) == 2) {
			if (GetHigh(p-&gt;rs-&gt;rs) &gt;= GetHigh(p-&gt;rs-&gt;ls))//一定要加等号，同下，就是因为这个，本蒟蒻92分调了55分钟！
				RightPlus(p);
			else
				RightLeft(p);
		}
	}
	else if(p-&gt;data &lt; x) {
		Erase(p-&gt;rs, x), update(p);
		if (GetHigh(p-&gt;ls) - GetHigh(p-&gt;rs) == 2) {
			if (GetHigh(p-&gt;ls-&gt;ls) &gt;= GetHigh(p-&gt;ls-&gt;rs))
				LeftPlus(p);
			else
				LeftRight(p);
		}
	}
	else {
		if (p-&gt;freq &gt; 1) {//如果这个数的频率大于1，那么直接减去一个就可以了
			--(p-&gt;freq);
			update(p);
			return;
		}
		if (p-&gt;ls &amp;&amp; p-&gt;rs) {//左右子树都有
			AVLtree q = p-&gt;rs;//找这个数的后继
			while (q-&gt;ls) q = q-&gt;ls;
			p-&gt;freq = q-&gt;freq;
			p-&gt;data = q-&gt;data, q-&gt;freq = 1;//把q节点提上来
			Erase(p-&gt;rs, q-&gt;data);//这个节点肯定少于2个子树了，直接删除
			update(p);//别忘记更新
			if (GetHigh(p-&gt;ls) - GetHigh(p-&gt;rs) == 2) {
				if (GetHigh(p-&gt;ls-&gt;ls) &gt;= GetHigh(p-&gt;ls-&gt;rs))
					LeftPlus(p);
				else
					LeftRight(p);
			}
		}
		else {//如果只有一个子树，直接把这个节点的子树提上来即可，不需要更新
			AVLtree q = p;
			if (p-&gt;ls) p = p-&gt;ls;
			else if (p-&gt;rs) p = p-&gt;rs;
			else p = NULL;
			delete q;
			q = NULL;
		}
	}
	if (p == NULL) return;//注意这里还要判断，否则可能会RE
	update(p);//最后更新一下
}
inline void erase(int x) {
	Erase(root, x);
}
</code></pre>
<h3 id="根据数值找排名">根据数值找排名：</h3>
<pre><code class="language-cpp">inline int get_rank(AVLtree p, int val) {
	if (p-&gt;data == val) return GetSize(p-&gt;ls) + 1;//如果这个节点就是要找的数字，返回左子树的大小加1
	if (p-&gt;data &gt; val) return get_rank(p-&gt;ls, val);//如果这个节点大于要找的数字，往左找
	return get_rank(p-&gt;rs, val) + GetSize(p-&gt;ls) + p-&gt;freq;//往右找，返回值要加上左子树的大小和这个节点数出现的频数
}
inline int GetRank(int val) {
	return get_rank(root, val);
}
</code></pre>
<h3 id="根据排名找数值">根据排名找数值：</h3>
<pre><code class="language-cpp">inline int get_val(AVLtree p, int rank) {
	if (GetSize(p-&gt;ls) &gt;= rank) return get_val(p-&gt;ls, rank);//如果左子树的大小不小于排名，往左找
	if (GetSize(p-&gt;ls) + p-&gt;freq &gt;= rank) return p-&gt;data;//如果左子树的大小加上这个节点数值出现的频数不小于排名，返回这个数值
	return get_val(p-&gt;rs, rank - GetSize(p-&gt;ls) - p-&gt;freq);//往右找，主要排名要减去左子树的大小和这个节点数值出现的频数
}
inline int GetVal(int rank) {
	return get_val(root, rank);
}
</code></pre>
<h3 id="找前驱后继">找前驱后继：</h3>
<pre><code class="language-cpp">inline int GetPrev(int val) {//找前驱
	AVLtree ans = new AVLnode(-1LL &lt;&lt; 42), p = root;//从根节点开始找，初始答案赋最小值
	while (p) {//如果p节点不为空，则一直找
		if (p-&gt;data == val) {
			if (p-&gt;ls) {//如果找到这个数了，先找这个数的左子树，再一直往右找
				p = p-&gt;ls;
				while (p-&gt;rs)
					p = p-&gt;rs;
				ans = p;
			}
			break;
		}
		if (p-&gt;data &lt; val &amp;&amp; p-&gt;data &gt; ans-&gt;data) ans = p;//如果遇到一个比这个值小但大于当前答案的值的话，把答案赋给ans
		p = p-&gt;data &lt; val ? p-&gt;rs : p-&gt;ls;
	}
	return ans-&gt;data;
}
inline int GetNext(int val) {//找后继，与找前驱类似
	AVLtree ans = new AVLnode(1LL &lt;&lt; 42), p = root;
	while (p) {
		if (p-&gt;data == val) {
			if (p-&gt;rs) {
				p = p-&gt;rs;
				while (p-&gt;ls)
					p = p-&gt;ls;
				ans = p;
			}
			break;
		}
		if (p-&gt;data &gt; val &amp;&amp; p-&gt;data &lt; ans-&gt;data) ans = p;
		p = p-&gt;data &lt; val ? p-&gt;rs : p-&gt;ls;
	}
	return ans-&gt;data;
}
</code></pre>
<h3 id="完整代码如下注释前面有了就不写了">完整代码如下(注释前面有了，就不写了)：</h3>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int N = 100000 + 10;
template&lt;class T&gt; inline void read(T &amp;x) {
	char c = 0;
	int f = x = 0;
	while (c &lt; 48 || c &gt; 57) {
		if (c == '-')
			f = 1;
		c = getchar();
	}
	while (c &gt; 47 &amp;&amp; c &lt; 58) x = (x &lt;&lt; 3)+(x &lt;&lt; 1)+(c &amp; 15), c = getchar();
	if (f) x = -x;
}
template&lt;class T,class... Args&gt; inline void read(T &amp;x, Args&amp;... args) {
	read(x), read(args...);
}
template&lt;class T&gt; inline void write(T x) {
	if (x &lt; 0) {
		putchar(45);
		write(-x);
		return;
	}
	if (x &gt; 9) write(x / 10);
	putchar((x % 10) | 48);
}
struct AVLnode;
typedef AVLnode* AVLtree;
struct AVLnode {
	int data, high;
	int freq, size;
	AVLtree ls, rs;
	AVLnode(): data(0), high(1), freq(1), size(1), ls(NULL), rs(NULL){}
	AVLnode(int a): data(a), high(1), freq(1), size(1), ls(NULL), rs(NULL){}
};
inline int GetSize(AVLtree p) {
	if (p == NULL) return 0;
	return p-&gt;size;
}
inline int GetHigh(AVLtree p) {
	if (p == NULL) return 0;
	return p-&gt;high;
}
struct AVL {
	AVLtree root;
	inline void update(AVLtree&amp; p) {
		p-&gt;size = GetSize(p-&gt;ls) + GetSize(p-&gt;rs) + p-&gt;freq;
		p-&gt;high = max(GetHigh(p-&gt;ls), GetHigh(p-&gt;rs)) + 1;
	}
	inline void LeftPlus(AVLtree&amp; p) {
		AVLtree q;
		q = p-&gt;ls;
		p-&gt;ls = q-&gt;rs;
		q-&gt;rs = p;
		update(p);
		update(q);
		p = q;
	}
	inline void RightPlus(AVLtree&amp; p) {
		AVLtree q;
		q = p-&gt;rs;
		p-&gt;rs = q-&gt;ls;
		q-&gt;ls = p;
		update(p);
		update(q);
		p = q;
	}
	inline void LeftRight(AVLtree&amp; p) {
		RightPlus(p-&gt;ls);
		LeftPlus(p);
	}
	inline void RightLeft(AVLtree&amp; p) {
		LeftPlus(p-&gt;rs);
		RightPlus(p);
	}
	inline void OutPut(AVLtree p) {
		if (p == NULL) return;
		OutPut(p-&gt;ls);
		for (int i = 1; i &lt;= p-&gt;freq; ++i)
			write(p-&gt;data), putchar(32);
		OutPut(p-&gt;rs);
	}
	inline void output() {
		OutPut(root);
	}
	inline void Insert(AVLtree &amp;p, int x) {
		if (p == NULL) {
			p = new AVLnode(x);
			return;
		}
		if (p-&gt;data == x) {
			++(p-&gt;freq);
			update(p);
			return;
		}
		if (p-&gt;data &gt; x) {
			Insert(p-&gt;ls, x), update(p);
			if (GetHigh(p-&gt;ls) - GetHigh(p-&gt;rs) == 2) {
				if (x &lt; p-&gt;ls-&gt;data)
					LeftPlus(p);
				else
					LeftRight(p);
			}
		}
		else {
			Insert(p-&gt;rs, x), update(p);
			if (GetHigh(p-&gt;rs) - GetHigh(p-&gt;ls) == 2) {
				if (x &gt; p-&gt;rs-&gt;data)
					RightPlus(p);
				else
					RightLeft(p);
			}
		}
		update(p);
	}
	inline void insert(int x) {
		Insert(root, x);
	}
	inline void Erase(AVLtree&amp; p, int x) {
		if (p == NULL) return;
		if (p-&gt;data &gt; x) {
			Erase(p-&gt;ls, x), update(p);
			if (GetHigh(p-&gt;rs) - GetHigh(p-&gt;ls) == 2) {
				if (GetHigh(p-&gt;rs-&gt;rs) &gt;= GetHigh(p-&gt;rs-&gt;ls))
					RightPlus(p);
				else
					RightLeft(p);
			}
		}
		else if(p-&gt;data &lt; x) {
			Erase(p-&gt;rs, x), update(p);
			if (GetHigh(p-&gt;ls) - GetHigh(p-&gt;rs) == 2) {
				if (GetHigh(p-&gt;ls-&gt;ls) &gt;= GetHigh(p-&gt;ls-&gt;rs))
					LeftPlus(p);
				else
					LeftRight(p);
			}
		}
		else {
			if (p-&gt;freq &gt; 1) {
				--(p-&gt;freq);
				update(p);
				return;
			}
			if (p-&gt;ls &amp;&amp; p-&gt;rs) {
				AVLtree q = p-&gt;rs;
				while (q-&gt;ls) q = q-&gt;ls;
				p-&gt;freq = q-&gt;freq;
				p-&gt;data = q-&gt;data, q-&gt;freq = 1;
				Erase(p-&gt;rs, q-&gt;data);
				update(p);
				if (GetHigh(p-&gt;ls) - GetHigh(p-&gt;rs) == 2) {
					if (GetHigh(p-&gt;ls-&gt;ls) &gt;= GetHigh(p-&gt;ls-&gt;rs))
						LeftPlus(p);
					else
						LeftRight(p);
				}
			}
			else {
				AVLtree q = p;
				if (p-&gt;ls) p = p-&gt;ls;
				else if (p-&gt;rs) p = p-&gt;rs;
				else p = NULL;
				delete q;
				q = NULL;
			}
		}
		if (p == NULL) return;
		update(p);
	}
	inline void erase(int x) {
		Erase(root, x);
	}
	inline int get_val(AVLtree p, int rank) {
		if (GetSize(p-&gt;ls) &gt;= rank) return get_val(p-&gt;ls, rank);
		if (GetSize(p-&gt;ls) + p-&gt;freq &gt;= rank) return p-&gt;data;
		return get_val(p-&gt;rs, rank - GetSize(p-&gt;ls) - p-&gt;freq);
	}
	inline int GetVal(int rank) {
		return get_val(root, rank);
	}
	inline int get_rank(AVLtree p, int val) {
		if (p-&gt;data == val) return GetSize(p-&gt;ls) + 1;
		if (p-&gt;data &gt; val) return get_rank(p-&gt;ls, val);
		return get_rank(p-&gt;rs, val) + GetSize(p-&gt;ls) + p-&gt;freq;
	}
	inline int GetRank(int val) {
		return get_rank(root, val);
	}
	inline int GetPrev(int val) {
		AVLtree ans = new AVLnode(-1LL &lt;&lt; 42), p = root;
		while (p) {
			if (p-&gt;data == val) {
				if (p-&gt;ls) {
					p = p-&gt;ls;
					while (p-&gt;rs)
						p = p-&gt;rs;
					ans = p;
				}
				break;
			}
			if (p-&gt;data &lt; val &amp;&amp; p-&gt;data &gt; ans-&gt;data) ans = p;
			p = p-&gt;data &lt; val ? p-&gt;rs : p-&gt;ls;
		}
		return ans-&gt;data;
	}
	inline int GetNext(int val) {
		AVLtree ans = new AVLnode(1LL &lt;&lt; 42), p = root;
		while (p) {
			if (p-&gt;data == val) {
				if (p-&gt;rs) {
					p = p-&gt;rs;
					while (p-&gt;ls)
						p = p-&gt;ls;
					ans = p;
				}
				break;
			}
			if (p-&gt;data &gt; val &amp;&amp; p-&gt;data &lt; ans-&gt;data) ans = p;
			p = p-&gt;data &lt; val ? p-&gt;rs : p-&gt;ls;
		}
		return ans-&gt;data;
	}
};
int n, x, opt;
AVL a;
signed main() {
	read(n);
	for (int i = 1; i &lt;= n; ++i) {
		read(opt, x);
		switch(opt) {
			case 1: a.insert(x); break;
			case 2: a.erase(x); break;
			case 3: write(a.GetRank(x)), putchar(10); break;
			case 4: write(a.GetVal(x)), putchar(10); break;
			case 5: write(a.GetPrev(x)), putchar(10); break;
			case 6: write(a.GetNext(x)), putchar(10); break;
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[测试]]></title>
        <id>https://YCE3216037.github.io/post/ce-shi/</id>
        <link href="https://YCE3216037.github.io/post/ce-shi/">
        </link>
        <updated>2020-03-17T12:17:46.000Z</updated>
        <content type="html"><![CDATA[<p>换了一台新电脑，看看能否保留原来写的博客</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://YCE3216037.github.io/post/hello-gridea/</id>
        <link href="https://YCE3216037.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>